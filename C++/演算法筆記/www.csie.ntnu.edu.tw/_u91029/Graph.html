<html lang="zh-TW">
<!-- Mirrored from www.csie.ntnu.edu.tw/~u91029/Graph.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Apr 2017 14:59:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=big5" /><!-- /Added by HTTrack -->
<head><meta charset="UTF-8" /><link rel="stylesheet" href="style.css" />
<title>演算法筆記 - Graph</title></head><body>
<div class="a"><div class="h">
<p class="b">Graph</p>
</div><div class="c">
<p class="t">Graph</p>
<img src="Graph1.png">
<p>Graph中文翻做「圖」。此處談及的「圖」並不是指圖片或者圖形。「圖」是一種用來記錄關聯、關係的東西。</p>
<img src="Graph2.png">
<p>一張圖由數個點（vertex）以及數條邊（edge）所構成。點與點之間，得以邊相連接，表示這兩點有關聯、關係。</p>
<img src="Graph3.png">
<p>點的大小形狀和線的粗細長短是無所謂的，我們只在乎它們如何連接。只要連接的關係對了，要怎麼畫都行，簡約、雅觀、平易近人即可！</p>
<img src="Graph4.png">
<p>兩點之間也可以有很多條邊，甚至有自己連到自己的邊。兩點之間有很多條邊，代表這兩點有很多項關聯。一個點有自己連到自己的邊，表示自己和自己有項關聯。</p>
<p class="t">Isomorphism / Isomorphic</p>
<p>Isomorphism中文譯作「同構」，Isomorphic中文譯作「同構的」。如果兩張圖的連接方式一模一樣時，則稱作「同構」。</p>
<img src="Graph5.png">
<p>圖上的邊可以是直的，也可以是彎彎曲曲的，也可以是交錯的。不論邊的形狀如何，都不會改變點與點之間的關聯、關係，終究都會是同構的圖。</p>
<img src="Graph6.png">
<p>圖上的點可以任意移動位置。不論點的位置如何，都不會改變點與點之間的關聯、關係，終究都會是同構的圖。</p>
<p>同構的圖擁有相同的資訊，所以不管選擇哪一張圖都是可以的，只要清楚易懂就可以了！</p>
<p class="t">Directed Graph（Digraph）</p>
<img src="Graph7.png">
<p>邊甚至可以擁有方向性，用來表示兩點間的關係是單向的，並非雙向的。無向邊代表雙向關係，有向邊代表單向關係。</p>
<p>一張圖若都是沒有方向性的邊，稱作「無向圖」；一張圖若都是有方向性的邊，則稱作「有向圖」。如果圖上有一些邊是單向的，有一些邊是雙向的，那我就不知道那該叫做什麼圖了。</p>
<p class="t">替點和邊加上權重</p>
<img src="Graph8.png">
<p>圖上的點可以擁有權重，可做其他用途。</p>
<img src="Graph9.png">
<p>圖上的邊可以擁有權重，可做其他用途。</p>
<p class="t">替點和邊取名字、代號</p>
<img src="Graph10.png">
<p>點和邊上面可以取名字、代號，方便辨認。名字、代號可以寫在點和邊的旁邊，也可以寫在點的裡面、邊的上面，只要能表達清楚就好。</p>
<img src="Graph11.png">
<p>名字可以隨便取，簡單明瞭就好。書上通常是用英文字母及數字居多。</p>

</div></div><div class="a"><div class="h">
<p class="b">Graph資料結構</p>
</div><div class="c">
<p class="t">Edge List</p>
<p>來談談如何利用程式語言來儲存一張圖吧！</p>
<img src="GraphDS1.png">
<p>最簡單的方式，就是用個陣列，記錄所有點與點之間的邊。這種方式相當直觀，也非常節省空間，但是卻不適合用於計算（請各位讀過圖論其他主題後，再來思考看看）。所以這裡要介紹其他類型的方法。</p>
<p>儲存一張圖的方式有許多種，這裡介紹其中兩種最常見的方法：adjacency matrix、adjacency lists。adjacency為「相鄰」之意，以邊相連接的兩個點，則稱這兩個點「相鄰」。</p>
<p class="t">Adjacency Matrix</p>
<img src="GraphDS2.png">
<p>把一張圖上的點依序標示編號，然後建立一個方陣，來記錄連接資訊。方陣中的每一個元素都代表著某兩點的連接資訊。例如元素(0,1)記錄著第0點到第1點的連接資訊、元素(4, 2)記錄著第4點到第2點的連接資訊。如此一來，任意兩個點之間的資訊，都有對應的地方可用於記錄，纖悉無遺。</p>
<img src="GraphDS3.png">
<p>連接資訊可以是邊的數目，也可以是邊的權重，也可以儲存其他的資訊。</p>
<img src="GraphDS4.png">
<p>值得一提的是，adjacency matrix可以用來記錄邊的權重。但是它卻沒辦法記錄點的權重，它也沒辦法同時記錄點和邊的權重。不過，要記錄點的權重，其實只要另外開一條陣列就行了，也不是什麼難事。</p>
<img src="GraphDS5.png">
<p>另外，當兩點之間的邊超過一條的時候，adjacency matrix沒辦法記錄權重，因為adjacency matrix的一個格子只能存入一個數字，沒辦法同時間存入多個數字。我們可以修改adjacency matrix的構造以存入更多數字，只是這不在討論範圍之內，各位可自行研究。</p>
<p>程式碼可以寫成這樣：</p>
<textarea>
int graph[5][5];
</textarea>
<textarea>
void adjacency_matrix()
{
	for (int i=0; i<5; ++i)
		for (int j=0; j<5; ++j)
			graph[i][j] = 0;

	int a, b, c;	// 一條邊的端點、另一個端點、邊的權重
	while (cin >> a >> b >> c)
		graph[a][b] = c;
}
</textarea>
<p class="t">Adjacency Lists</p>
<img src="GraphDS6.png">
<p>把一張圖上的點依序標示編號。每一個點，後方串連所有相鄰的點。例如第4列之中所列的數字，即是與第4點相鄰的點。</p>
<p>第一種，是古板的實作方式，自行實作list：</p>
<textarea>
struct Element
{
	int v;
	Element* next;
};

// 製造五個List，作為Adjacency Lists。
Element* list[5];

void add_edge(int a, int b)
{
	Element* e = new Element();
	e->v = b;
	e->next = list[a];
	list[a] = e;
}
</textarea>
<textarea>
void adjacency_lists()
{
	for (int i=0; i<5; ++i)
	{
		recursive_delete(list[i]);
		list[i] = 0;
	}

	int a, b;	// 一條邊的端點、另一個端點
	while (cin >> a >> b)
		add_edge(a, b);
}

void recursive_delete(Element* e)
{
	if (!e) return;
	recursive_delete(e->next);
	delete e;
}
</textarea>
<p>第二種，是輕鬆的實作方式，利用程式語言內建的list或vector：</p>
<textarea>
// 製造五個動態陣列，作為Adjacency Lists。
vector<int> list[5];
</textarea>
<textarea>
void adjacency_lists()
{
	for (int i=0; i<5; ++i)
		list[i].clear();

	int a, b;	// 一條邊的端點、另一個端點
	while (cin >> a >> b)
		list[a].push_back(b);
}
</textarea>
<p>第三種，是簡約的實作方式，適用於邊數不多時：</p>
<textarea>
int list[5][50];	// 邊數上限是50
int size[5];		// 記錄每一個列表的元素有多少個
</textarea>
<textarea>
void adjacency_lists()
{
	for (int i=0; i<5; ++i)
		size[i] = 0;

	int a, b;	// 一條邊的端點、另一個端點
	while (cin >> a >> b)
		list[a][size[a]++] = b;
}
</textarea>
<p>第四種，是奇妙的實作方式，把邊依序放入陣列：</p>
<textarea>
int adj[5];
int next[50], from[50], to[50];
int e = 0;	// 邊數

void add_edge(int a, int b)
{
	// 設定這條邊的端點
//	from[e] = a;	// 事實上不需要
	to[e] = b;

	// 把邊插入到list開頭
	next[e] = adj[a];
	adj[a] = e;
	e++;
}
</textarea>
<textarea>
void adjacency_lists()
{
	e = 0;
	for (int i=0; i<5; ++i)
		adj[i] = -1;

	int a, b;	// 一條邊的端點、另一個端點
	while (cin >> a >> b)
		add_edge(a, b);
}
</textarea>
<p>如果還要記錄邊的權重，就變成這樣：</p>
<textarea>
struct Element
{
	int v, w;	// 同時記錄邊的權重
	Element* next;
};

Element* list[5];
</textarea>
<textarea>
struct Element {int v, w;}; // 同時記錄邊的權重
vector<Element> list[5];
</textarea>
<textarea>
vector< pair<int,int> > list[5]; // 用pair來代替兩個變數的struct
</textarea>
<textarea>
int list[5][5];
int weight[5][5]; // 再開一個陣列來記錄邊的權重
int size[5];
</textarea>
<textarea>
const int V = 10;
const int E = 1000;
// 再開一個陣列來記錄邊的權重
int adj[V], next[E], to[E], weight[E];
int e = 0;
</textarea>
<p>如果還要記錄點的權重，那就另外再開一條陣列吧。</p>

</div></div><div class="a"><div class="h">
<p class="b">Graph Traversal</p>
</div><div class="c">
<p class="t">Graph Traversal</p>
<img src="GraphTraversal1.png">
<p>給你一張圖，要怎麼讀出它的資訊呢？</p>
<p>用人眼來觀察一張圖，很快的就能看出點和線，一點一點釐清關係。要是一張圖能夠畫得漂亮一點，上個鮮明的顏色，那就更好了。</p>
<img src="GraphTraversal2.png">
<p>電腦則不然。要以電腦來讀取一張圖的資訊（這資訊想必會以圖的資料結構來妥善儲存），唯一的方法就是透過程式語言，以及良好的演算法囉！</p>
<p>Traversal中文稱作「遍歷」。圖的遍歷，也就是指通盤地讀取圖的資訊：決定好從哪裡開始讀，依照什麼順序讀，要讀到哪裡為止。詳細地設計好流程，始能通盤地讀取圖的資訊；如果設計得漂亮，在解決圖的問題時，還可以一邊讀取圖的資訊，一邊順手解決問題呢！</p>
<p>利用最簡單的資料結構queue和stack，就能製造不同的遍歷順序，得到兩種遍歷演算法：Breadth-first Search和Depth-first Search。這兩個演算法充分了利用程式語言的特性，簡約而美麗，成為資訊領域不可不知的演算法。</p>

</div></div><div class="a"><div class="h">
<p class="b">Graph Traversal: Breadth-first Search</p>
</div><div class="c">
<p class="t">Breadth-first Search（BFS）</p>
<pre>
（依照編號順序）不斷找出尚未遍歷的點當作起點，進行下述行為：
　一、把起點放入queue。
　二、重複下述兩步驟，直到queue裡面沒有東西為止：
　　甲、從queue當中取出一點。
　　乙、找出跟此點相鄰的點，並且尚未遍歷的點，
　　　　通通（依照編號順序）放入queue。
</pre>
<p>教科書都有一步一步的示意圖，這裡不再重畫，只做額外補充。</p>
<img src="BFS1.png">
<p>運用BFS遍歷整張圖，最後得到許多棵樹。單一的樹稱作BFS Tree，所有的樹稱作BFS Forest。</p>
<p>不同的起點，形成不同的BFS Forest。我們習慣按照編號順序選擇下一個要拜訪的點，得到唯一一種BFS Forest。</p>
<p class="t">遍歷順序示意圖：每個點進入與離開queue的時刻</p>
<img src="BFS2.png">
<p>每個點進入queue的時刻以左上深色數字表示，每個點離開queue的時刻以右下淺色數字表示。每個點都會進入queue一次、離開queue一次，不會再有第二次。</p>
<p class="t">遍歷順序示意圖：每個點離開queue的時刻</p>
<img src="BFS3.png">
<p>只觀察離開queue的時刻，可以發現BFS優先走遍距離起點最近之處，優先讓BFS Tree變得寬廣，因而得名Breadth-first Search。這個遍歷順序能夠解決許多圖論問題！</p>
<p class="t">時間複雜度</p>
<p>使用的資料結構為adjacency matrix的話，可以以O(V^2)時間遍歷整張圖；使用adjacency lists的話，可以以O(V+E)時間遍歷整張圖。V是圖上的點數，E是圖上的邊數。</p>
<p class="t">程式碼（adjacency matrix）</p>
<textarea>
bool adj[9][9];	// 一張圖，資料結構為adjacency matrix。
bool visit[9];	// 記錄圖上的點是否遍歷過，有遍歷過為true。

void BFS()
{
	// 建立一個queue。
	queue<int> q;

	// 全部的點都初始化為尚未遍歷
	for (int i=0; i<9; i++)
		visit[i] = false;

	for (int k=0; k<9; k++)
		if (!visit[k])
		{
			// 一、把起點放入queue。
			q.push(k);
			visit[k] = true;

			// 二、重複下述兩點，直到queue裡面沒有東西為止：
			while (!q.empty())
			{
				// 甲、從queue當中取出一點。
				int i = q.front(); q.pop();

				// 乙、找出跟此點相鄰的點，並且尚未遍歷的點，
				//     依照編號順序通通放入queue。
				for (int j=0; j<9; j++)
					if (adj[i][j] && !visit[j])
					{
						q.push(j);
						visit[j] = true;
					}
			}
		}
}
</textarea>
<textarea>
// 很差的寫法，點從queue彈出來之後才設定遍歷過了。
bool adj[9][9];
bool visit[9];

void BFS()
{
	queue<int> q;

	for (int i=0; i<9; i++)
		visit[i] = false;

	for (int k=0; k<9; k++)
		if (!visit[k])
		{
			q.push(k);

			while (!q.empty())
			{
				int i = q.front(); q.pop();

				if (!visit[i])
				{
					visit[i] = true;

					for (int j=0; j<9; j++)
						if (adj[i][j] && !visit[j])
							q.push(j);
				}
			}
		}
}
</textarea>

</div></div><div class="a"><div class="h">
<p class="b">Graph Traversal: Depth-first Search</p>
</div><div class="c">
<p class="t">Depth-first Search（DFS）</p>
<p>DFS與BFS大同小異，只是把queue換成了stack而已。</p>
<img src="DFS1.png">
<p class="t">遍歷順序示意圖：每個點進入與離開stack的時刻</p>
<img src="DFS2.png">
<p>每個點進入stack的時刻以左上深色數字表示，每個點離開stack的時刻以右下淺色數字表示。每個點都會進入stack一次、離開stack一次，不會再有第二次。</p>
<p class="t">遍歷順序示意圖：每個點離開stack的時刻</p>
<img src="DFS3.png">
<p>只觀察離開stack的時刻，可以發現DFS優先走遍距離起點最遠之處，優先讓DFS Tree變得深遠，因而得名Depth-first Search。這個遍歷順序能夠解決許多圖論問題！</p>
<p class="t">遞迴版本程式碼（adjacency matrix）</p>
<p>DFS的程式碼也可以寫成遞迴形式。程式語言中的遞迴，其實就是利用stack來實作的。</p>
<textarea>
bool adj[9][9];	// 一張圖，資料結構為adjacency matrix。
bool visit[9];	// 記錄圖上的點是否遍歷過，有遍歷過為true。

void DFS(int i)
{
	for (int j=0; j<9; j++)
		if (adj[i][j] && !visit[j])
		{
			visit[j] = true;	// 標記為已遍歷
			DFS(j);
		}
}

void traversal()
{
	// 全部的點都初始化為尚未遍歷
	for (int i=0; i<9; i++)
		visit[i] = false;

	for (int i=0; i<9; i++)
		if (!visit[i])
		{
			visit[i] = true;
			DFS(i);
		}
}
</textarea>
<textarea>
bool adj[9][9];
bool visit[9];

void DFS(int i)
{
	visit[i] = true;

	for (int j=0; j<9; j++)
		if (adj[i][j] && !visit[j])
			DFS(j);
}

void traversal()
{
	for (int i=0; i<9; i++)
		visit[i] = false;

	for (int i=0; i<9; i++)
		if (!visit[i])
			DFS(i);
}
</textarea>
<textarea>
bool adj[9][9];
bool visit[9];

void DFS(int i)
{
	if (visit[i]) return;
	visit[i] = true;

	for (int j=0; j<9; j++)
		if (adj[i][j])
			DFS(j);
}

void traversal()
{
	for (int i=0; i<9; i++)
		visit[i] = false;

	for (int i=0; i<9; i++)
		DFS(i);
}
</textarea>
<p class="t">遍歷順序示意圖：每個點進入遞迴與離開遞迴的時刻</p>
<img src="DFS4.png">
<p>進入遞迴的時刻以左上深色數字表示，離開遞迴的時刻以右下淺色數字表示。這個順序用於解決一些特別的圖論問題。</p>
<p>製圖時，DFS Tree高度至少是三、分枝數目至少是三，比較容易觀察出遍歷順序。建議讀者也自己畫個圖、寫段程式研究一下。</p>
<p class="t">邊的分類</p>
<img src="DFS5.png">
<p>藉由一叢DFS Forest，一張有向圖的邊可以分成四類：</p>
<pre>
Tree Edge：樹上的邊。
Back Edge：連向祖先的邊。（形成環）
Forward Edge：連向子孫的邊。
Cross Edge：枝葉之間的邊、樹之間的邊。（可能形成環）
</pre>
<p>藉由一叢DFS Forest，一張無向圖的邊可以分成兩類：</p>
<pre>
Tree Edge：樹上的邊。
Back Edge：連向祖先的邊。（形成環）
</pre>
<p>這些邊的分類，可以協助我們解決複雜的圖論問題。</p>
<pre>
d[x] : 節點 x 進入遞迴的時刻
f[x] : 節點 x 離開遞迴的時刻
(i, j) is a tree edge or a froward edge : d[i] < d[j] < f[j] < f[i]
(i, j) is a back edge : d[j] < d[i] < f[i] < f[j]
(i, j) is a cross edge : d[j] < f[j] < d[i] < f[i]
</pre>

</div></div><div class="a"><div class="h">
<p class="b">Graph Property</p>
</div><div class="c">
<p class="t">先看個圖片</p>
<p>圖片中省略了點的編號。</p>
<img src="GraphProperty1.png">
<p class="t">degree</p>
<img src="GraphProperty2.png">
<p>一個點的「度」：一個點的邊數量。</p>
<p>有向圖，細分成入邊數量in-degree、出邊數量out-degree。</p>
<p class="t">neighbor</p>
<img src="GraphProperty3.png">
<p>一個點的「鄰居」：一個點連往的點。可能有許多個、零個。</p>
<p>無向圖，鄰居數量是邊數量。有向圖，鄰居數量是出邊數量。</p>
<p>順便補充幾個常見形容詞。</p>
<pre>
adjacent：相鄰、鄰接。只走一步，可以抵達。
connected：相連、連通。不限步數，可以抵達。
</pre>
<p class="t">distance</p>
<img src="GraphProperty4.png">
<p>兩個點的「距離」：從起點走到終點的邊數量，數量必須最低。</p>
<p>如果兩點之間不連通，距離是無限大。約定成俗。</p>
<img src="GraphProperty5.png">
<p>指定起點，實施Breadth-first Search，就可以算出起點走到圖上各點的距離。利用這種方式，可以算出兩點之間的距離。大家可以試試看！</p>
<p>額外補充一下。當數量必須最低，改成了數量必須最高，則無法透過遍歷演算法求得答案，只能透過backtracking窮舉所有路線，一一判斷答案。數量必須最高，已被證明是NP-complete問題，目前沒有（以後大概也不會有）快速的演算法。</p>

</div></div><div class="a"><div class="h">
<p class="b">Graph Manipulation</p>
</div><div class="c">
<p class="t">Intersection Graph</p>
<p>圖用來表達兩兩之間的關係。例如一群人，我們可以建立「朋友關係」的圖，兩個人是朋友就連一條邊，兩個人不是朋友就沒有邊。只要是兩兩之間的關係，就得以轉化成圖，運用圖論知識來分析問題。</p>
<p>其中有個值得一提的關係是「交集關係」，是聯集交集的那個交集。兩個東西有交集就連一條邊（交集不是空集合）、沒交集就沒有邊（交集是空集合），最後得到的圖叫做「交集圖」。</p>
<p>例如一堆線段，把互相接觸的線段，表示成圖：</p>
<img src="IntersectionGraph1.png">
<p>例如一堆集合，把有交集的集合，表示成圖：</p>
<img src="IntersectionGraph2.png">
<p>比較特別的交集圖，數學家會特地取名。例如一堆硬幣，平鋪在桌上，把互相接觸的硬幣，表示成圖，稱作Coin Graph。數學家發現硬幣圖和平面圖兩者完全等價，每一種平面圖都可以利用硬幣接觸兜出來。</p>
<img src="IntersectionGraph3.png">
<p>例如行程表，把撞期的行程，表示成圖，稱作Interval Graph，有著很特別的數學性質。</p>
<img src="IntersectionGraph4.png">
<p>例如一張圖論的圖，把共用端點的邊，表示成圖，就是先前提到的Line Graph。</p>
<img src="IntersectionGraph5.png">
<p>為什麼數學家特別重視交集圖呢？我也不知道。</p>
<p>很多人把交集圖看做是一個物品。但是交集圖其實是一種變換的概念，可以看做是一個函數。</p>
<p class="t">Dependency Graph【尚無正式名稱】</p>
<p>除了「交集關係」之外，數學家也很重視「依賴關係」。把各個東西的仰賴對象表示成圖，最後得到的圖叫做「依賴圖」。</p>
<p>例如一堆不等式，把變數大小關係，表示成圖：</p>
<img src="DependencyGraph1.png">
<p>比較特別的依賴圖，數學家會特地取名。例如專案管理領域，把工作先後次序，表示成圖，稱作「<a href="DirectedAcyclicGraph.html">Activity Network</a>」。</p>
<img src="DependencyGraph2.png">
<p>例如2-SAT問題，把各個clause裡面的兩個變數的取捨關係，表示成圖，稱作「<a href="Component.html">Implication Graph</a>」。</p>
<img src="DependencyGraph3.png">
<p>交集圖是無向圖、依賴圖是有向圖，剛好一對。</p>
<p class="t">Subgraph / Supergraph</p>
<p>一張圖，刪除一些點、一些邊，得到的圖稱作「子圖」。</p>
<p>原圖（沒有刪除）、空圖（完全刪除），也算是「子圖」。</p>
<img src="GraphManipulation1.png">
<p>一張圖，增加一些點、一些邊，得到的圖稱作「父圖」。</p>
<p>原圖（沒有增加）也算是「父圖」。</p>
<img src="GraphManipulation2.png">
<p>subgraph和supergraph是相對的。如果A是B的子圖，那麼B就是A的父圖。我們習慣只講子圖，講一個就等於兩個都講了。</p>
<p class="t">Induced Subgraph / Induced Supergraph</p>
<p>一張圖，保留一些點、以及這些點之間的所有邊，得到的圖稱作「導出子圖」。</p>
<img src="GraphManipulation3.png">
<p>一張圖，增加一些點、一些邊，但是不在原本的點之間增加邊，使得原本的圖是導出子圖，得到的圖稱作「導出父圖」。</p>
<img src="GraphManipulation4.png">
<p>induced subgraph和induced supergraph是相對的。如果A是B的導出子圖，那麼B就是A的導出父圖。我們習慣只講導出子圖，講一個就等於兩個都講了。</p>
<p class="t">Minor / Subdivision</p>
<p>一張圖，收縮一些邊、合併一些點，得到的圖稱作minor。</p>
<p>收縮的邊，有人視情況刪除，也有人視情況不刪除、而變成連向自己的邊。</p>
<img src="GraphManipulation5.png">
<p>一張圖，在邊上植入點，得到的圖稱作subdivision。</p>
<img src="GraphManipulation6.png">
<p>minor和subdivision是相對的。一般只討論minor。</p>
<p class="e">ICPC 4023</p>
<p class="t">Oriented Graph / Underlying Graph</p>
<p>一張無向圖，無向邊改成有向邊，稱做「定向圖」。</p>
<img src="GraphManipulation7.png">
<p>一張有向圖，有向邊改成無向邊，稱作「底圖」。</p>
<img src="GraphManipulation8.png">
<p>定向圖和底圖是相對的。一般只討論定向圖。</p>
<p class="t">Complement Graph（Complement）</p>
<p>一張圖，兩點之間沒邊變有邊、有邊變沒邊，稱作「補圖」。</p>
<p>原圖暨補圖的所有邊，合起來是完全圖。</p>
<img src="GraphManipulation9.png">
<p>朋友變仇人、有關變無關，整個相反顛倒，就是補圖的用處。</p>
<p class="t">Reverse Graph（Transpose）</p>
<p>一張有向圖，邊的方向顛倒，稱作「反向圖」。</p>
<img src="GraphManipulation10.png">
<p>主動變被動、前進變後退，整個相反顛倒，就是反向圖的用處。</p>
<p class="t">Line Graph</p>
<p>一張圖當中，觀察邊與邊關係，相鄰的邊表示成一張圖，稱作「線圖」。</p>
<img src="GraphManipulation11.png">
<p class="e">UVa 10988 11175</p>
<p class="t">Dual Graph</p>
<p>一張平面圖當中，觀察面與面關係，共邊的面表示成一張圖，稱作「對偶圖」。詳情請參考「<a href="PlanarGraph.html">Planar Graph</a>」。</p>
<img src="GraphManipulation12.png">

</div></div><div class="a"><div class="h">
<p class="b">Hypergraph</p>
</div><div class="c">
<p class="t">Hypergraph</p>
<img src="Hypergraph1.png">
<p>「圖」是談兩個東西之間的關係，「超圖」則是談多個東西之間的關係，例如三個東西之間的關係。</p>
<p>超圖的資料結構，不適合採用adjacency matrix，因為矩陣必須變成多個維度，浪費記憶體空間。比較好的方式是採用incidence matrix。</p>
<p>一般的圖就很夠用了，通常不會用到超圖。</p>
</div></div><script src="h.js"></script></body>
<!-- Mirrored from www.csie.ntnu.edu.tw/~u91029/Graph.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Apr 2017 15:00:28 GMT -->
</html>